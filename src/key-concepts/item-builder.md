<script setup lang="ts">
import DocImg from '../../components/DocImg.vue'

const fixtureUrl = "../api/Twizzar.Fixture/";

const itemBuilderUrl = `${fixtureUrl}ItemBuilder-2.html`;
const buildUrl = `${fixtureUrl}ItemBuilder-2/Build.html`;
const withUrl = `${fixtureUrl}ItemBuilder-2/With.html`;

const memberConfigUrl = "../api/Twizzar.Fixture.Member/MemberConfig-1.html";

// image source
import TwizzarNestedFiles from '../images/Twizzar_Nested_Files.png';
import TwizzarCustomItemBuilder from '../images/Twizzar_Custom_Item_Builder.png';
</script>

# Item Builder
The <a :href="itemBuilderUrl">ItemBuilder</a> is the entry point for configuring a Fixture Item. The <a :href="itemBuilderUrl">ItemBuilder</a> uses the builder pattern to provide a fluent API for configuring the dependencies of the instance requested. We call the requested instance Fixture Item in Twizzar.

## Builder pattern
To get an instance of a type with TWIZZAR the `ItemBuilder` can be used:
```c#
using Twizzar.Fixture;
var potion = new ItemBuilder<Potion>().Build();
```
The Item builder follows the builder pattern, so when <a :href="buildUrl">`Build`</a> is called a new instance of the type is created. To configure the instance the <a :href="withUrl">`With`</a> method can be used before calling <a :href="buildUrl">`Build`</a>.):

```c#
using Twizzar.Fixture;

// Generates a potion with the name: mana potion
var potion = new ItemBuilder<Potion>()
    .With(p => p.Name.Value("Mana Potion"))
    .Build();
```

::: tip
If you are using C#10 use `global using Twizzar.Fixture;` in your unit test project.
:::

The <a :href="withUrl">`With`</a> method can be used to configure members of the Fixture Item. The With method accepts a function which returns a <a :href="memberConfigUrl">`MemberConfig`</a> to create this <a :href="memberConfigUrl">`MemberConfig`</a> Twizzar provides a path class as a parameter to the function to select and then configure a member.

::: details Definition member
In Twizzar we consider the following as a member of a class, struct, interface or record:

- field
- property
- method (only available for interfaces)
- constructor parameter
  :::

The path class is automatically generated by the Twizzar. Analyzer with a [Source Generator](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview). Properties fields can be selected by their name, constructor parameter can be selected with `Ctor.<ParameterName>` and methods can be selected by `<MethodName>_<ReturnType>`. We call it a path class because it is possible to access members further down in the dependency tree. When a potion with an ingredient with the name "Mana Potion" as the Ingredient1 property is required as show in this tree:

```
Potion
┗━ Ingredient1
   ┗━ Name: "Mana Potion"
```

It can be selected over the path class by selecting the right path `p.Ingredient1.Name`. Or also over the constructor: `p.Ctor.ingredient1.Name`.

When we look at the [Potion](https://github.com/Twizzar/Twizzar/blob/main/examples/PotionDeliveryService/PotionDeliveryService/Potions.cs), it requires four additional parameters to be created.

```c#
public class Potion
{
    public Potion(
        string name,
        IIngredient ingredient1,
        IIngredient ingredient2,
        IEffect effect,
        PotionColor color)
        {
            ...
        }
}
```

But we only configured the name. Twizzar provides for all not configured members a [default behavior](./default-behavior), for example for a string a unique value will be used and for an interface a mock object will be used. For classes or structs, the greatest constructor will be used and all its parameter will be resolved with the default behavior.

::: details Definition of the greatest constructor
The greatest constructor is defined as the constructor with the most parameters. When there are more than one constructor with max parameters, then one is selected over a hash function by Twizzar. The selection is arbitrary but deterministic. This always means the same constructor is selected.
:::

## Dependency tree

## Custom Item Builder

When a Fixture Item is configured over the [Twizzar UI](./twizzar-ui) a new Custom Item Builder will be declared, this required the following steps:

1.  A new File is generated with the postfix `.twizzar.cs` for projects with the new cproj structure, the File will be nested under the unit test.
    <DocImg :src="TwizzarNestedFiles" alt="Nested Files"/>
2.  The unit test class will be made partial.
3.  In the new generated file, a new partial class for the unit test class is generated
4.  A new Custom Item Builder class is generated in the generated file.
5.  The `new ItemBuilder<T>()` statement will be changed to `new CustomItemBuilderName()`
6.  For the CustomItemBuilderName a unique name will be generated.

<DocImg :src="TwizzarCustomItemBuilder" alt="Custom Item Builder"/>

::: tip
Rename the auto generated name of the Custom Item Builder with the Visual Studio refactor option to something meaning full like ManaPotionBuilder.
:::

When further configurations are made, then they will be added to the Custom Item Builder constructor body. It is also possible to write your own code into the Custom Item Builder if desired. The generated Custom Item Builder are generated to only be visible by the unit test where they were generated. It is also possible to move them as desired. The Twizzar UI will work regardless of the location of the Custom Item Builder as long as the type is discoverable by the unit test.
