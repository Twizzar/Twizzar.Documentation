import{_ as e,o as t,c as a,Q as i}from"./chunks/framework.a9d1f0e8.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"basic-types.md","filePath":"basic-types.md"}'),s={name:"basic-types.md"},n=i('<p>All Basic types can be configured as unique. Basic types have a value and no members. The following types are basic types:</p><ul><li>Numeric Basic Types</li><li>string</li><li>char</li><li>enums</li></ul><h2 id="numeric-basic-types" tabindex="-1">Numeric Basic Types <a class="header-anchor" href="#numeric-basic-types" aria-label="Permalink to &quot;Numeric Basic Types&quot;">​</a></h2><table><thead><tr><th>Category</th><th>Type</th></tr></thead><tbody><tr><td>Signed integral</td><td>sbyte, short, int, long</td></tr><tr><td>Unsigned integral</td><td>byte, ushort, uint, ulong</td></tr><tr><td>IEEE binary floating-point</td><td>float, double</td></tr><tr><td>High-precision decimal floating-point</td><td>decimal</td></tr></tbody></table><h2 id="unique-value-of-basic-types" tabindex="-1">Unique value of basic types <a class="header-anchor" href="#unique-value-of-basic-types" aria-label="Permalink to &quot;Unique value of basic types&quot;">​</a></h2><p><strong>Numeric Basic Types</strong><br> The algorithm to determine a new unique number acts on the underlying bit sequence of a certain numeric type. It alters the bit sequence to get a new not before seen number, till the definition space of the type is fully used, then it will start at the beginning.</p><p><strong>string</strong><br> Uses <code>Guid.NewGuid().ToString();</code>.</p><p><strong>char</strong><br> Uses the same algorithm as the Numeric Basic Types.</p>',8),r=[n];function o(c,l,d,u,p,h){return t(),a("div",null,r)}const y=e(s,[["render",o]]);export{m as __pageData,y as default};
